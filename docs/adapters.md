# AtlasBridge Adapter Interface Specification

**Version:** 1.0.0
**Status:** Frozen (GA)
**Last updated:** 2026-02-23

---

## 1. Purpose

AtlasBridge is a universal human-in-the-loop control plane. It wraps AI CLI tools in a PTY and routes every interactive prompt to a remote channel so the user can respond from anywhere. The core relay logic — detection, routing, injection, persistence, audit — is tool-agnostic. The *adapter* layer is the thin seam that makes this work for any specific CLI.

### Vendor-Neutral Philosophy

Every AI CLI tool presents prompts differently. Claude Code shows approval dialogs in ANSI-styled blocks. A future OpenAI CLI tool might emit bare `>` cursors. A custom Python agent might write `[AWAITING INPUT]` JSON events to stdout. Rather than hard-coding knowledge of one tool into the supervisor, AtlasBridge defines an abstract `BaseAdapter` contract that any tool can satisfy.

The design goals are:

- **Zero core changes** — adding support for a new tool requires creating one new file in `src/atlasbridge/adapters/` and registering it.
- **Fail-safe** — if an adapter cannot parse or classify an event, it must return `None` from `detect_prompt`. The blocking heuristic (Layer 3 in the supervisor) then catches it.
- **PTY fidelity** — every adapter must preserve the full terminal experience: colour, readline, cursor control, Ctrl-C handling. A user running `atlasbridge run <tool>` should see no difference from running the tool directly.
- **Transparent injection** — when the user replies, the adapter's `inject_reply` writes exactly the bytes the tool expects, no more, no less.
- **Observable** — `snapshot_context` returns a rich dictionary suitable for the status display and for debugging.

The current production adapter is `ClaudeCodeAdapter`. The `OpenAIAdapter` is a registered stub. Additional adapters can be contributed without any change to the PTY supervisor, Telegram bot, policy engine, or database layer.

---

## 2. BaseAdapter Interface

The following code constitutes the canonical definition of the adapter contract. All adapters in `src/atlasbridge/adapters/` must subclass `BaseAdapter` and implement every abstract method.

```python
# src/atlasbridge/adapters/base.py
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import StrEnum
from typing import Any, AsyncIterator


class PromptType(StrEnum):
    TYPE_YES_NO = "yes_no"
    TYPE_CONFIRM_ENTER = "confirm_enter"
    TYPE_MULTIPLE_CHOICE = "multiple_choice"
    TYPE_FREE_TEXT = "free_text"


class Confidence(StrEnum):
    HIGH = "high"   # >= 0.85: pattern match, multiple signals
    MED = "medium"  # 0.65–0.84: single pattern match
    LOW = "low"     # 0.60–0.64: blocking heuristic only


@dataclass
class PromptEvent:
    """
    A prompt detected in the tool's output stream.

    This is the outbound DTO produced by the adapter and consumed by
    the supervisor, policy engine, and channel layer.
    """
    prompt_id: str          # UUID v4; generated by the adapter
    session_id: str         # UUID v4; generated when the session starts
    prompt_type: PromptType
    confidence: Confidence
    excerpt: str            # Redacted/truncated display text (max 200 chars)
    choices: list[str]      # For TYPE_MULTIPLE_CHOICE and TYPE_YES_NO; empty otherwise
    constraints: dict[str, Any]  # Type-specific validation hints, e.g. {"max_length": 200}
    idempotency_key: str    # Deduplication key; see Section 5
    timestamp: str          # ISO 8601 UTC, e.g. "2026-02-21T14:30:00.123456+00:00"
    raw_bytes: bytes        # Original terminal bytes from the PTY (NOT forwarded to channel)


@dataclass
class Reply:
    """
    A resolved reply from the channel layer, ready to be injected into the tool.

    This is the inbound DTO produced by the channel and consumed by the adapter's
    inject_reply method.
    """
    prompt_id: str
    session_id: str
    value: str              # Normalized string to inject, e.g. "y", "n", "1", "some text"
    nonce: str              # Single-use token from the PromptEvent; validated before injection
    channel_identity: str   # Origin of the reply, e.g. "telegram:123456789"
    timestamp: str          # ISO 8601 UTC
    newline_policy: str     # "append" | "none" | "replace" — see Section 4


class BaseAdapter(ABC):
    """
    Abstract base for all AtlasBridge tool adapters.

    An adapter is responsible for:
      1. Spawning the supervised CLI in a PTY and returning a session ID.
      2. Streaming raw PTY output bytes to the supervisor.
      3. Analysing buffered output to detect whether the CLI is waiting for input.
      4. Reporting whether the CLI's stdin is blocked.
      5. Injecting a human reply back into the CLI's stdin with correct formatting.
      6. Cleanly terminating the session on exit or error.
      7. Providing a context snapshot for observability and debugging.
      8. Reporting its own health (connected, child alive, PTY writable).

    Adapters must NOT:
      - Make policy decisions (allow/deny/escalate). That is the policy engine's job.
      - Send messages to channels. That is the channel layer's job.
      - Write to the audit log directly. The supervisor owns audit writes.
      - Block the event loop. All I/O must be async or delegated to an executor.
    """

    @abstractmethod
    async def start_session(
        self,
        command: list[str],
        env: dict[str, str] | None = None,
    ) -> str:
        """
        Spawn the CLI process inside a PTY.

        Parameters
        ----------
        command:
            The full command and arguments, e.g. ["claude", "--model", "opus"].
        env:
            Optional environment overrides. The adapter is responsible for
            sanitising the child environment (stripping ATLASBRIDGE_* secrets).

        Returns
        -------
        str
            The session_id for this invocation (UUID v4).

        Raises
        ------
        AdapterStartError
            If the process cannot be spawned (binary not found, permission denied, etc.).
        """

    @abstractmethod
    async def read_stream(self) -> AsyncIterator[bytes]:
        """
        Yield raw bytes from the supervised CLI's stdout/stderr.

        The supervisor reads from this iterator and simultaneously:
          - Forwards every byte to the host terminal unchanged.
          - Accumulates a rolling detection buffer.
          - Feeds the buffer to detect_prompt after each chunk.

        Implementations must yield chunks as they arrive from the PTY; do not
        buffer aggressively. Target latency: < 5 ms from PTY read to yield.

        Yields
        ------
        bytes
            A single read chunk (1–1024 bytes) from the PTY master fd.
        """

    @abstractmethod
    async def detect_prompt(self, buffer: bytes) -> PromptEvent | None:
        """
        Analyse a rolling output buffer and return a PromptEvent if a prompt is detected.

        Parameters
        ----------
        buffer:
            The most recent bytes of PTY output (max 4096 bytes, rolling window).
            ANSI escape sequences are included; the implementation must strip them
            before pattern matching.

        Returns
        -------
        PromptEvent | None
            A populated PromptEvent if a prompt is detected with confidence >= threshold,
            else None. The adapter must not return a PromptEvent for the same underlying
            prompt twice (use the idempotency_key to deduplicate).
        """

    @abstractmethod
    async def await_input_state(self) -> bool:
        """
        Return True if the CLI is currently blocked waiting for stdin input.

        This is the signal for the supervisor's stall watchdog. The default
        implementation (blocking heuristic) compares the time since last PTY output
        against stuck_timeout_seconds. Tool-specific adapters can override this with
        a more precise signal (e.g., a structured event from the tool).

        Returns
        -------
        bool
            True if the process is waiting for input and no output has arrived
            for at least stuck_timeout_seconds.
        """

    @abstractmethod
    async def inject_reply(self, reply: Reply) -> None:
        """
        Inject the reply value into the CLI's stdin.

        The adapter must:
          1. Pause stdin relay (set _injecting = True).
          2. Map reply.value to the correct byte sequence using newline_policy.
          3. Write the bytes to the PTY master fd.
          4. Clear the output buffer so the prompt text cannot re-trigger detection.
          5. Resume stdin relay (set _injecting = False).

        Parameters
        ----------
        reply:
            The resolved reply from the channel layer. The adapter must validate
            that reply.nonce matches the stored nonce for reply.prompt_id before
            writing any bytes.

        Raises
        ------
        AdapterInjectionError
            If the PTY write fails (e.g., child has exited).
        ReplayAttackError
            If reply.nonce does not match or has already been used.
        """

    @abstractmethod
    async def terminate_session(self, session_id: str) -> None:
        """
        Cleanly terminate the CLI session.

        The adapter must:
          1. Send SIGTERM to the child process.
          2. Wait up to 3 seconds for it to exit.
          3. Send SIGKILL if it has not exited.
          4. Close the PTY master fd.
          5. Restore the host terminal settings (termios).

        Parameters
        ----------
        session_id:
            The session_id returned by start_session. The adapter should validate
            that it matches the active session.
        """

    @abstractmethod
    async def snapshot_context(self) -> dict[str, Any]:
        """
        Return a serializable snapshot of the current session context.

        Used by:
          - `atlasbridge status` (displayed in the Rich status table)
          - `atlasbridge doctor` (health diagnostics)
          - The supervisor's debug logging

        The returned dictionary must include at minimum:
          {
            "session_id": str,
            "tool": str,
            "pid": int | None,
            "state": str,          # "running" | "awaiting_response" | "injecting" | "done"
            "uptime_seconds": float,
            "prompt_count": int,
            "last_output_ago_seconds": float,
            "pty_alive": bool,
          }
        Additional adapter-specific keys are allowed.
        """

    @abstractmethod
    async def healthcheck(self) -> bool:
        """
        Return True if the adapter and its supervised session are healthy.

        A healthy adapter satisfies all of:
          - The child process is alive (has not exited).
          - The PTY master fd is open and writable.
          - The internal asyncio tasks (pty_reader, stall_watchdog, etc.) are running.

        Returns
        -------
        bool
            True if healthy; False if any condition fails.
        """
```

---

## 3. PromptEvent and Reply Schemas

### 3.1 PromptEvent Field Descriptions

| Field | Type | Description |
|---|---|---|
| `prompt_id` | `str` | UUID v4. Generated fresh for every detected prompt. Used as the primary key in the SQLite `prompts` table and embedded in every Telegram callback. |
| `session_id` | `str` | UUID v4. Identifies the `atlasbridge run` invocation. Matches the `sessions` table primary key. |
| `prompt_type` | `PromptType` | Classified type of the prompt. One of `TYPE_YES_NO`, `TYPE_CONFIRM_ENTER`, `TYPE_MULTIPLE_CHOICE`, `TYPE_FREE_TEXT`. |
| `confidence` | `Confidence` | Classification confidence band: `HIGH` (>= 0.85), `MED` (0.65–0.84), `LOW` (0.60–0.64). Drives the safe-default safety margin. |
| `excerpt` | `str` | Truncated, ANSI-stripped display text. Hard limit of 200 characters. Trailing content is replaced with `…`. This is what the user sees in the channel message. Must not contain passwords, API keys, or other secrets; the adapter is responsible for light redaction of common secret patterns. |
| `choices` | `list[str]` | For `TYPE_MULTIPLE_CHOICE`: the labelled option strings extracted from the output, e.g. `["Install", "Skip", "Abort"]`. For `TYPE_YES_NO`: may contain `["Yes", "No"]` or remain empty. Empty for other types. Capped at 9 entries. |
| `constraints` | `dict[str, Any]` | Validation hints for the channel layer. Standard keys: `max_length` (int, for free text), `min_choice` (int, 1-indexed), `max_choice` (int). The channel uses these to validate the user's reply before routing it to the supervisor. |
| `idempotency_key` | `str` | Deduplication key. See Section 5. |
| `timestamp` | `str` | ISO 8601 UTC timestamp at the moment the prompt was detected. Used for TTL calculation and audit correlation. |
| `raw_bytes` | `bytes` | The exact PTY output bytes that triggered detection. This field is used for debugging and is never forwarded to the channel. It is stored in the SQLite record (as BLOB) for post-session analysis only. |

### 3.2 Reply Field Descriptions

| Field | Type | Description |
|---|---|---|
| `prompt_id` | `str` | Must match the `prompt_id` of the pending `PromptEvent`. The adapter rejects replies for unknown or already-answered prompt IDs. |
| `session_id` | `str` | Must match the active session. Cross-session reply injection is not allowed. |
| `value` | `str` | The normalized reply value to inject. For yes/no: `"y"` or `"n"`. For confirm-enter: `"\n"`. For multiple-choice: `"1"` through `"9"`. For free text: the raw string (max 200 chars). For default: the prompt's `safe_default`. |
| `nonce` | `str` | `secrets.token_hex(16)` (128 bits), generated when the `PromptEvent` is created. Single-use. The adapter validates this against the stored nonce and marks it used before injection. |
| `channel_identity` | `str` | Human-readable source of the reply, in the form `"<channel>:<identifier>"`. Examples: `"telegram:123456789"`, `"slack:U012AB3CD"`, `"auto:timeout"`, `"cli:local"`. Written to the `decided_by` column in SQLite and to the audit log. |
| `timestamp` | `str` | ISO 8601 UTC timestamp at the moment the channel received the user's reply. |
| `newline_policy` | `str` | Controls how a carriage return is appended to the injected value. See Section 4. |

### 3.3 Validation Rules

**PromptEvent:**
- `prompt_id` must be a valid UUID v4 string.
- `excerpt` must not exceed 200 bytes when encoded as UTF-8.
- `choices` must have at most 9 entries; each entry must not exceed 60 characters.
- `timestamp` must be a valid ISO 8601 string with UTC timezone.
- `confidence` values below `LOW` (< 0.60) must not produce a `PromptEvent`; the adapter must return `None`.

**Reply:**
- `value` for `TYPE_FREE_TEXT` must not exceed `constraints["max_length"]` (default 200).
- `value` for `TYPE_MULTIPLE_CHOICE` must be a digit string in the range `[1, len(choices)]`.
- `value` for `TYPE_YES_NO` must be `"y"` or `"n"`.
- `nonce` must be exactly 32 hex characters (16 bytes, token_hex(16) output).
- `newline_policy` must be one of `"append"`, `"none"`, `"replace"`.

---

## 4. Newline Policy

When a reply value is injected into the PTY's stdin, the bytes written must match what the CLI expects. Most CLIs expect a carriage return or newline to confirm the input; others treat the character literally. The `newline_policy` field controls this.

### `"append"` (default)

The carriage return `\r` is appended after the value.

```
inject_bytes = value.encode("utf-8") + b"\r"
```

Used for: all standard cases — yes/no confirmations, multiple-choice selection, free-text input. This is the behaviour of pressing Enter after typing a response in a normal terminal.

### `"none"`

No newline is appended. The raw encoded value is written verbatim.

```
inject_bytes = value.encode("utf-8")
```

Used for: single-character interactive CLIs that act on keypress without Enter (e.g., `less` pager, `vim`-style menus). Also used when the value itself already contains a newline (e.g., `value = "\n"` for `TYPE_CONFIRM_ENTER`).

### `"replace"`

The entire value is treated as a byte sequence string (backslash-decoded), not a text string. This allows callers to inject raw control sequences.

```
inject_bytes = value.encode("utf-8").decode("unicode_escape").encode("latin-1")
```

Used for: Escape key injection (`"\x1b"`), Ctrl-C (`"\x03"`), Ctrl-D (`"\x04"`), or other control characters needed to dismiss a blocking prompt. Only the Claude Code adapter uses this policy currently, for the rare case where a prompt must be dismissed with a non-text signal.

### Mapping Table

| PromptType | Default policy | Injected bytes (example value `"y"`) |
|---|---|---|
| `TYPE_YES_NO` | `append` | `b"y\r"` |
| `TYPE_CONFIRM_ENTER` (value `"\n"`) | `none` | `b"\r"` |
| `TYPE_MULTIPLE_CHOICE` | `append` | `b"1\r"` |
| `TYPE_FREE_TEXT` | `append` | `b"my text\r"` |
| `TYPE_FREE_TEXT` (empty default) | `none` | `b"\r"` |

The supervisor's `INJECT_BYTES` lookup table (in `atlasbridge/core/constants.py`) pre-computes these mappings for the common cases. The adapter's `inject_reply` implementation should consult this table first, then fall back to the newline policy for custom values.

---

## 5. Idempotency Key

### Purpose

When AtlasBridge operates under high load, reconnects after a network blip, or has the same PTY output read twice due to a buffer boundary, the same prompt text might trigger `detect_prompt` multiple times. The idempotency key prevents the supervisor from creating multiple `PromptEvent` records for the same physical prompt occurrence.

### Generation

The idempotency key is a SHA-256 hex digest computed from three inputs:

```python
import hashlib, time

def make_idempotency_key(
    session_id: str,
    excerpt: str,
    timestamp_window_seconds: int = 5,
) -> str:
    # Quantize the current time to a N-second window so that two detections
    # of the same prompt within the same window produce the same key.
    window = int(time.time()) // timestamp_window_seconds
    raw = f"{session_id}:{excerpt}:{window}"
    return hashlib.sha256(raw.encode("utf-8")).hexdigest()
```

The time window (default 5 seconds) is intentionally short. Two genuinely different prompts that produce identical excerpt text within the same 5-second window (extremely unlikely) will be deduplicated — this is an acceptable trade-off against double-sending the same prompt.

### Deduplication Logic

The supervisor maintains an in-memory `set[str]` of recently seen idempotency keys:

```python
_recent_idempotency_keys: set[str] = set()
_IDEMPOTENCY_WINDOW_EVENTS = 32   # max keys kept in memory
```

Before creating a `PromptRecord` in SQLite, the supervisor checks:

```python
if event.idempotency_key in _recent_idempotency_keys:
    log.debug("Duplicate prompt suppressed: key=%s", event.idempotency_key[:16])
    return  # do not create DB record, do not send to channel
_recent_idempotency_keys.add(event.idempotency_key)
if len(_recent_idempotency_keys) > _IDEMPOTENCY_WINDOW_EVENTS:
    _recent_idempotency_keys.pop()  # evict oldest (set is unordered; approximate LRU)
```

After a successful injection, the output buffer is cleared (`_output_buffer.clear()`), which resets the raw bytes that fed the detection. This prevents the same text from matching again immediately after injection. The idempotency key provides a secondary defence for the window between detection and buffer clear.

---

## 6. Claude Code Adapter

### 6.1 Overview

The `ClaudeCodeAdapter` is the production adapter for the Claude CLI (`claude` binary). It wraps Claude in a PTY using `ptyprocess.PtyProcess`, monitors its output via a 4096-byte rolling buffer, and classifies prompts using a three-layer detection stack that mirrors the existing `PromptDetector`.

Source location: `src/atlasbridge/adapters/claude.py` (target path; currently implemented inline in `atlasbridge/bridge/pty_supervisor.py`).

### 6.2 Detection Patterns Specific to Claude Code

Claude Code renders its interactive UI using ANSI colour codes, Unicode box-drawing characters, and inline keyboard-like option displays. All detection must run on ANSI-stripped text.

#### Approval Dialog (most common)

Claude Code shows confirmation dialogs for potentially dangerous tool calls. The canonical pattern is:

```
╭─ Bash Tool ─────────────────────────────────────────╮
│ rm -rf /tmp/build                                   │
╰─────────────────────────────────────────────────────╯
Do you want to run this? (y/n) ❯
```

Detection pattern (applied to ANSI-stripped output):

```python
re.compile(
    r"do\s+you\s+want\s+to\s+(?:run|execute|proceed|continue|allow)\s+this\?.*[\[\(]?[Yy]\s*/\s*[Nn][\]\)]?",
    re.IGNORECASE | re.DOTALL,
)
```

Confidence: `HIGH` (0.90). Claude's phrasing is consistent across versions.

#### File Edit Confirmation

When `--no-auto-edit` is active or for write operations that exceed a threshold:

```
Edit /Users/ara/project/src/main.py? (y/n)
```

Pattern:

```python
re.compile(
    r"(?:edit|write|modify|create|delete|overwrite)\s+\S+\?.*\([Yy]/[Nn]\)",
    re.IGNORECASE,
)
```

Confidence: `HIGH` (0.88).

#### Bash Run Confirmation

```
Run bash command? (y/n)
  $ git push origin main --force
```

Pattern:

```python
re.compile(
    r"run\s+bash\s+command\?.*[\[\(][Yy]/[Nn][\]\)]",
    re.IGNORECASE | re.DOTALL,
)
```

Confidence: `HIGH` (0.90).

#### Interactive Selection Menu

When Claude presents a numbered menu for tool or model selection:

```
Select an action:
  1) Apply changes
  2) View diff
  3) Skip this file
  4) Abort
Enter choice [1-4]:
```

This matches `TYPE_MULTIPLE_CHOICE` patterns in the existing `PromptDetector`. The adapter extracts choices using `re.findall(r"^\s*(\d+)[)\.]\s+(.+)$", text, re.MULTILINE)`.

#### Press Enter to Continue

Claude uses this pattern after displaying diffs or long output:

```
Press Enter to continue...
```

Matches `TYPE_CONFIRM_ENTER` patterns.

### 6.3 Handling Partial-Line Prompts

Claude Code occasionally writes prompt text incrementally: the question text arrives in one PTY chunk, and the `(y/n)` suffix arrives in a subsequent chunk 10–50 ms later. If detection runs after each chunk independently, the first chunk may not match any pattern.

The adapter addresses this by running detection on the cumulative buffer (up to 4096 bytes) rather than on each individual chunk. The `_output_buffer` accumulates chunks and detection is invoked after every chunk. This ensures that by the time the `(y/n)` suffix arrives, the full prompt text is in the buffer and matches.

For prompts that never complete with a recognisable suffix (bare `> ` cursor), the stall watchdog fires after `stuck_timeout_seconds` (default 2.0s) and triggers `detect_blocking()` with `TYPE_UNKNOWN` at confidence `LOW`.

### 6.4 Injection Format

After a reply arrives, `inject_reply` writes the appropriate bytes to the PTY master fd:

| Reply value | Bytes written | Notes |
|---|---|---|
| `"y"` | `b"y\r"` | Confirms yes |
| `"n"` | `b"n\r"` | Confirms no (safe default for YES_NO) |
| `"enter"` / `"\n"` | `b"\r"` | Presses Enter |
| `"1"`–`"9"` | `b"N\r"` | Multiple-choice selection by number |
| `""` (empty) | `b"\r"` | Empty Enter for free-text default |
| Free text | `text.encode("utf-8") + b"\r"` | User-typed reply |
| `"default"` | Safe default bytes for the prompt type | Resolved by caller before injection |

Carriage return (`\r`, ASCII 0x0D) rather than newline (`\n`, ASCII 0x0A) is used because PTY slaves in canonical mode translate `\r` to the Enter keystroke. Writing `\n` directly would be interpreted differently by some CLIs.

After writing, the adapter:
1. Calls `_output_buffer.clear()`.
2. Resets `_last_output_time` to `now`.
3. Sets `_injecting = False`.
4. Sets `_state = SupervisorState.RUNNING`.

This prevents the same prompt text from re-triggering detection in the next read cycle.

---

## 7. OpenAI CLI Adapter (Stub)

### 7.1 Status

**Implementation status:** Stub. The class is registered in the adapter registry but raises `NotImplementedError` on `start_session`. It will be promoted to full implementation in Phase 3.

### 7.2 What Would Be Needed

The OpenAI CLI (`openai`) differs from Claude Code in several ways that affect adapter design:

**Prompt format differences:**
- The OpenAI CLI tends to use bare colon-terminated prompts (`Enter your API key:`, `Confirm? [y/N]`) rather than boxed dialogs.
- Interactive confirmations may appear in `stderr` rather than `stdout`, requiring the PTY adapter to merge both streams into the detection buffer.

**Structured output mode:**
- If `openai` supports a `--output-format json-stream` equivalent, the adapter can use Layer 1 (structured event) detection at confidence 1.0 by watching for JSON objects conforming to the OpenAI tool call schema.

**Required implementation:**
1. `start_session`: spawn `openai` with `ptyprocess`, same as the Claude adapter.
2. `detect_prompt`: add OpenAI-specific pattern sets to `_YES_NO_PATTERNS`, `_CONFIRM_ENTER_PATTERNS`, etc. The patterns will be narrower since the OpenAI CLI uses simpler prompt text.
3. `inject_reply`: identical implementation to the Claude adapter; the byte-level PTY protocol is the same.
4. `snapshot_context`: extend with `openai_version` and `model` fields parsed from the CLI's startup output.

**Stub registration:**

```python
# src/atlasbridge/adapters/openai_cli.py
from atlasbridge.adapters.base import BaseAdapter
from atlasbridge.adapters.registry import AdapterRegistry

@AdapterRegistry.register("openai")
class OpenAIAdapter(BaseAdapter):
    """OpenAI CLI adapter — stub, Phase 3."""

    async def start_session(self, command, env=None):
        raise NotImplementedError("OpenAI adapter not yet implemented. Use 'claude' adapter.")
    # ... all other methods raise NotImplementedError
```

---

## 8. Adding a New Adapter

To add support for a new AI CLI tool, follow these steps:

### Step 1: Create the adapter module

```
src/atlasbridge/adapters/<tool_name>.py
```

For example, for a hypothetical `gemini` CLI:

```
src/atlasbridge/adapters/gemini.py
```

### Step 2: Subclass BaseAdapter

```python
# src/atlasbridge/adapters/gemini.py
from atlasbridge.adapters.base import BaseAdapter, PromptEvent, Reply
from atlasbridge.adapters.registry import AdapterRegistry
from typing import Any, AsyncIterator


@AdapterRegistry.register("gemini")
class GeminiAdapter(BaseAdapter):
    """Adapter for Google Gemini CLI."""

    SUPPORTED_VERSIONS = [">=0.1.0"]
    TOOL_NAME = "gemini"
```

### Step 3: Implement all abstract methods

Implement each of the eight abstract methods on `BaseAdapter`. See Section 2 for full docstrings. The minimum viable implementation for a new tool is:

- `start_session`: use `ptyprocess.PtyProcess.spawn(command, dimensions=(rows, cols))`.
- `read_stream`: yield chunks from `os.read(self._proc.fd, 1024)` in a loop.
- `detect_prompt`: delegate to `PromptDetector.detect(ansi_stripped_text)` for generic detection, then add tool-specific patterns on top.
- `await_input_state`: compare `time.monotonic() - last_output_time` against `stuck_timeout_seconds`.
- `inject_reply`: write `INJECT_BYTES.get(reply.value, reply.value.encode() + b"\r")` to the PTY fd.
- `terminate_session`: send `SIGTERM`, wait 3s, then `SIGKILL`.
- `snapshot_context`: return the minimum required dictionary.
- `healthcheck`: check `self._proc.isalive()`.

### Step 4: Register tool-specific patterns

If the tool has unique prompt signatures, add them to a `_TOOL_PATTERNS` list in the adapter module and merge them with the base `PromptDetector` patterns:

```python
_GEMINI_YES_NO_PATTERNS = [
    re.compile(r"Confirm action\? \[Y/n\]", re.IGNORECASE),
    re.compile(r"Proceed with deployment\?", re.IGNORECASE),
]
```

Override `detect_prompt` to try tool-specific patterns first (at higher base confidence), then fall through to generic patterns.

### Step 5: Write tests

Create `tests/unit/adapters/test_<tool_name>_adapter.py`. Include at minimum:

- One test per known prompt signature using `detect_prompt` with fixture PTY output.
- One test verifying that `detect_prompt` returns `None` for normal (non-prompt) output.
- One test for `inject_reply` with each prompt type to confirm correct byte sequences.
- One test for idempotency key deduplication.

Run the Prompt Lab scenarios against your adapter (see Section 9).

### Step 6: Document detection patterns

Add a subsection to this document (Section 6 pattern) describing the tool's known prompt signatures, confidence values, and any quirks. Submit the documentation alongside the code in the same pull request.

---

## 9. Adapter Test Harness (Prompt Lab)

### Overview

The Prompt Lab (`tests/prompt_lab/`) provides a replay-based test harness for adapter development. It works by playing back captured PTY output sequences and asserting that `detect_prompt` returns the correct `PromptEvent` (or `None`).

### Scenario Files

Scenarios live in `tests/prompt_lab/scenarios/`. Each scenario is a `.json` file with the following schema:

```json
{
  "tool": "claude",
  "scenario_id": "claude_yes_no_file_overwrite",
  "description": "Claude Code asking to overwrite an existing file",
  "pty_output": "Do you want to overwrite /src/main.py? (y/n) ",
  "expected_type": "TYPE_YES_NO",
  "expected_confidence_band": "HIGH",
  "expected_excerpt_contains": "overwrite /src/main.py",
  "expected_choices": []
}
```

Scenarios with `expected_type: null` assert that `detect_prompt` returns `None` (non-prompt output).

### Running the Prompt Lab

```bash
# Run all scenarios for all adapters
pytest tests/prompt_lab/ -v

# Run only Claude adapter scenarios
pytest tests/prompt_lab/ -v -k "claude"

# Run with verbose detection output
pytest tests/prompt_lab/ -v --capture=no
```

### Adding Scenarios

To capture a new scenario from a live session, set `ATLASBRIDGE_CAPTURE_PROMPTS=1` before running:

```bash
ATLASBRIDGE_CAPTURE_PROMPTS=1 atlasbridge run claude
```

AtlasBridge writes a `.json` scenario file to `~/.atlasbridge/captured_scenarios/` for each detected prompt. Copy these files to `tests/prompt_lab/scenarios/` and annotate them with the expected fields.

### Regression Protection

The Prompt Lab CI job (`pytest tests/prompt_lab/`) runs on every pull request that modifies `src/atlasbridge/adapters/`. A PR that breaks any existing scenario must either fix the regression or, if the tool's output format changed, update the scenario file with a documented rationale.
